{
  "__format":".pl",
  "__rel_path":"/srv/local/pl/premierlangage/home/Yggdrasil/Mathematics/exercises/complex_numbers/affixe.pl",
  "__comment":"\n# Author : D. Doyen\n# Tags : complex numbers\n# 19/8/2020",
  "__files":{
    "customjsxgraph.py":"from components import Component\nfrom jinja2 import Template\n\nclass CustomJSXGraph(Component):\n\n    def __init__(self, **kwargs):\n        self.selector = 'c-math-drawer'\n        self.decorator = 'CustomJSXGraph'\n        super().__init__(**kwargs)\n\n    def setscript(self, script, dic={}):\n        \"\"\"\n        Set script and render it.\n        \"\"\"\n        self.script = Template(script).render(dic)\n\n    def addscript(self, script, dic={}):\n        \"\"\"\n        Add a script and render it.\n        \"\"\"\n        self.script += Template(script).render(dic)\n\n    def getpoint(self, name):\n        \"\"\"\n        Set script and render it.\n        \"\"\"\n        return (self.points[name]['x'], self.points[name]['y'])\n\n\n\n\n\n",
    "json_encoder.py":"import json, jsonpickle\nimport sympy\n\ntry:\n    from namespace import namespace\nexcept ModuleNotFoundError:\n    namespace = {}\n\nclass CustomEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, (sympy.Basic, sympy.Matrix)):\n            return {'__SymPy__': True, 'srepr': sympy.srepr(obj)}\n        return jsonpickle.Pickler(unpicklable=False).flatten(obj)\n\nclass CustomDecoder(json.JSONDecoder):\n    def __init__(self, *args, **kwargs):\n        json.JSONDecoder.__init__(self, object_hook=self.object_hook, *args, **kwargs)\n\n    def object_hook(self, dict):\n        if '__SymPy__' in dict:\n            return sympy.sympify(dict['srepr'], locals=namespace, evaluate=False)\n        return dict\n\n\n",
    "jinja_env.py":"from jinja2 import Environment, BaseLoader\nfrom sympy2latex import latex\n\ndef component(l):\n    if isinstance(l,dict):\n        selector = l[\"selector\"]\n        cid = l[\"cid\"]\n    else:\n        selector = l.selector\n        cid = l.cid\n    return \"<%s cid='%s'></%s>\" % (selector, cid, selector)\n\nCustomEnv = Environment(loader=BaseLoader())\nCustomEnv.filters[\"component\"] = component\nCustomEnv.filters[\"latex\"] = latex\n\n",
    "serialize2.py":"from sympy import Basic, Expr, Matrix, Tuple, sympify, srepr\nfrom sympy2latex import latex\n\ndef deserialize(arg):\n    if isinstance(arg, dict) and 'serialize' in arg and arg['serialize'] == \"SymPy\" :\n        return sympify(arg['srepr'], evaluate=False)\n    elif isinstance(arg, dict):\n        return {k: deserialize(v) for k, v in arg.items()}\n    elif isinstance(arg, list):\n        return list(map(deserialize,arg))\n    elif isinstance(arg, tuple):\n        return tuple(map(deserialize,arg))\n    else:\n        return arg\n\ndef serialize(arg):\n    if isinstance(arg, (Basic, Matrix)):\n        return {'serialize': 'SymPy', 'srepr': srepr(arg), 'latex': latex(arg)}\n    elif isinstance(arg,dict):\n        return {k: serialize(v) for k, v in arg.items()}\n    elif isinstance(arg,list):\n        return list(map(serialize,arg))\n    elif isinstance(arg,tuple):\n        return tuple(map(serialize,arg))\n    else:\n        return arg\n\n\n\n\n\n\n",
    "namespace.py":"from sympy import *\n# Delete SymPy objects which create name conflicts\n# Actually, it would be better to make specific imports...\ndel C \nimport random as rd\nfrom randsympy import *\nfrom evalsympy import *\nfrom latex2sympy import *\nfrom sympy2latex import *\n\nnamespace = globals().copy()\n\n",
    "evalsympy.py":"import sympy as sp\nfrom latex2sympy import *\n\n# Utils\n\ndef equal(a, b, modulo=None):\n    \"\"\"\n    Check if two expressions are equal after simplification.\n    \"\"\"\n    if a == b:\n        return True\n\n    diff = a - b\n    if isinstance(diff, sp.Expr) and diff.is_complex:\n        diff = sp.expand_complex(diff)\n    \n    if modulo is None:\n        return sp.simplify(diff) == 0\n    else:\n        return sp.simplify(diff) % modulo == 0\n\ndef equal_approx(a, b, tol, modulo=None):\n    \"\"\"\n    Check if two expressions are approximately equal.\n    \"\"\"\n    if modulo is None:\n        return abs(a - b).evalf() < tol\n    else:\n        return abs((abs(a - b) + modulo/2) % modulo - modulo/2).evalf() < tol\n\ndef equal_struct(p, q, modulo=None):\n    \"\"\"\n    Check if two nested structures of lists and tuples of expressions \n    (where lists are viewed as sets) are equal.\n    \n    >>> equal_struct([1,2,3], [3,1,2])\n    True\n    \n    >>> equal_struct([sp.sqrt(2)/2, 0], [0, 1/sp.sqrt(2)])\n    True\n    \n    >>> equal_struct((1,2,3), (3,1,2))\n    False\n    \n    >>> equal_struct([(1, 2), (2, 3)], [(2, 3), (1, 2)])\n    True\n    \"\"\"\n    \n    # comparison of two lists (viewed as sets)\n    if isinstance(p, list) and isinstance (q, list):\n        if len(p) != len(q):\n            return False\n        for a in p:\n            isin = False\n            for b in q:\n                if equal_struct(a, b, modulo):\n                    isin = True\n                    break\n            if not isin:\n                return False\n        return True\n     \n    # comparison of two tuples       \n    elif isinstance(p, tuple) and isinstance (q, tuple):\n        if len(p) != len(q):\n            return False\n        for i in range(len(p)):\n            if not equal_struct(p[i], q[i], modulo):\n                return False\n        return True\n    \n    # comparison of two expressions        \n    elif isinstance(p, (sp.Expr, int)) and isinstance (q, (sp.Expr, int)):\n        return equal(p, q, modulo)\n    \n    # other cases\n    else:    \n        return False\n\n\ndef duplicates(p):\n    \"\"\"\n    Check if there are duplicates in lists inside a nested structure of\n    lists and tuples of expressions.\n    \n    >>> duplicates([1, 2, 3, 2])\n    True\n    \n    >>> duplicates([0, sp.sqrt(2)/2, 1/sp.sqrt(2)])\n    True\n    \n    >>> duplicates([(1, 2), (2, 1)]) \n    False\n    \n    >>> duplicates([[1, 2], [2, 1]]) \n    True\n    \"\"\"\n    \n    # search duplicates in lists\n    if isinstance(p, list):\n        if len(p) > 1:\n            for i in range(len(p)):\n                for j in range(i+1, len(p)):\n                    if equal_struct(p[i], p[j]):\n                        return True\n    \n    # search duplicates in elements of lists and tuples                  \n    if isinstance(p, (list, tuple)):\n        for a in p:\n            if duplicates(a):\n                return True\n\n    return False\n\ndef arg_nested_add(expr):\n    \"\"\"\n    Return the terms of a nested sum.\n    \"\"\"\n    if not expr.is_Add:\n        return [expr]\n    args = []\n    for a in expr.args:\n        if a.is_Add:\n            args = args + arg_nested_add(a)\n        else:\n            args.append(a)\n    return args\n\ndef arg_nested_mul(expr):\n    \"\"\"\n    Return the terms of a nested product.\n    \"\"\"\n    if not expr.is_Mul:\n        return [expr]\n    args = []\n    for a in expr.args:\n        if a.is_Mul:\n            args = args + arg_nested_mul(a)\n        else:\n            args.append(a)\n    return args\n    \ndef is_coeff_mul(expr, x):\n    \"\"\"\n    Check if an expression is of the form 'something times x'.\n    \"\"\"\n    args = arg_nested_mul(expr)\n    return args.count(x) == 1 and sum([a.has(x) for a in args]) == 1\n\ndef coeff_mul(expr, x):\n    \"\"\"\n    Return the multiplicative coefficient.\n    \n    >>> x = sp.Symbol('x')\n    >>> expr = sp.sympify(\"3*x/2\", evaluate=False)\n    >>> coeff_mul(expr, x)\n    3/2\n    \n    >>> expr = sp.sympify(\"4*x/2\", evaluate=False)\n    >>> coeff_mul(expr, x)\n    4/2\n    \n    >>> expr = sp.sympify(\"(1+sqrt(2))*x\", evaluate=False)\n    >>> coeff_mul(expr, x)\n    1 + sqrt(2)\n    \n    >>> coeff_mul(x, x)\n    1\n    \"\"\"\n    args = arg_nested_mul(expr)\n    args.remove(x)\n    if len(args) == 0:\n        return sp.Integer(1)\n    elif len(args) == 1:\n        return args[0]\n    else:\n        with sp.evaluate(False):\n            return sp.Mul(*args)\n    \ndef is_coeff_exponent(expr, x):\n    \"\"\"\n    Check if an expression is of the form 'something times x power something'.\n    \"\"\"\n    n = sp.degree(sp.simplify(expr), x)\n    if n == 0:\n        return True\n    args = arg_nested_mul(expr)\n    return args.count(x**n)==1 and sum([a.has(x) for a in args])==1\n    \ndef coeff_exponent(expr, x):\n    \"\"\"\n    Return the multiplicative coefficient.\n    \n    >>> x = sp.Symbol('x')\n    >>> expr = sp.sympify(\"3*x**2/2\", evaluate=False)\n    >>> coeff_exponent(expr, x)\n    (3/2, 2)\n    \n    >>> expr = sp.sympify(\"4/2\", evaluate=False)\n    >>> coeff_exponent(expr, x)\n    (4/2, 0)\n    \n    >>> expr = sp.sympify(\"(1+sqrt(2))*x\", evaluate=False)\n    >>> coeff_exponent(expr, x)\n    (1 + sqrt(2), 1)\n    \n    >>> coeff_exponent(x**3, x)\n    (1, 3)\n    \"\"\"\n    n = sp.degree(expr, x)\n    if n == 0:\n        return (expr, n)\n    args = arg_nested_mul(expr)\n    args.remove(x**n)\n    if len(args) == 0:\n        return (sp.Integer(1), n)\n    elif len(args) == 1:\n        return (args[0], n)\n    else:\n        with sp.evaluate(False):\n            return (sp.Mul(*args), n)\n\ndef is_real_or_inf(expr):\n    \"\"\"\n    Check if an expression is real or equal to infinity.\n    \"\"\"\n    if expr == sp.S.Infinity or expr == sp.S.NegativeInfinity:\n        return True\n    return expr.is_real and not expr.is_infinite\n\ndef is_rat_simp(expr):\n    \"\"\"\n    Check if the rational numbers in an expression are simplified.\n    \n    >>> expr = sp.sympify(\"2/4\", evaluate=False)\n    >>> is_rat_simp(expr)\n    False\n    \n    >>> expr = sp.sympify(\"1 - 1/2\", evaluate=False)\n    >>> is_rat_simp(expr)\n    False\n    \n    >>> expr = sp.sympify(\"sqrt(1 + 1)\", evaluate=False)\n    >>> is_rat_simp(expr)\n    False\n    \n    >>> expr = sp.sympify(\"1 + sqrt(2)\", evaluate=False)\n    >>> is_rat_simp(expr)\n    True\n    \"\"\"\n    if isinstance(expr, sp.Expr):\n        if sp.simplify(expr).is_rational:\n            return is_frac_int(expr) and is_frac_irred(expr)\n        elif expr.is_Atom or expr.is_Boolean:\n            return True\n        else:\n            return all(is_rat_simp(subexpr) for subexpr in expr.args)\n    elif isinstance(expr, (list, tuple, sp.Tuple, set, sp.FiniteSet)):\n        return all(is_rat_simp(item) for item in expr)\n    else:\n        return True\n\ndef is_frac_int(expr):\n    \"\"\"\n    Check if an expression is a fraction of integers.\n    \n    >>> expr = sp.sympify(\"3\", evaluate=False)\n    >>> is_frac_int(expr)\n    True\n    \n    >>> expr = sp.sympify(\"1 + 3\", evaluate=False)\n    >>> is_frac_int(expr)\n    False\n    \n    >>> expr = sp.sympify(\"5*7/2\", evaluate=False)\n    >>> is_frac_int(expr)\n    False\n    \"\"\"\n    args = arg_nested_mul(expr)\n    # remove sign\n    if len(args) > 1 and sp.Integer(-1) in args:\n        args.remove(sp.Integer(-1))\n    with sp.evaluate(False):\n        expr = sp.Mul(*args)\n    f = sp.fraction(expr, exact=True)\n    return f[0].is_Integer and f[1].is_Integer\n\ndef is_frac_irred(expr):\n    \"\"\"\n    Check if a fraction of integers is irreducible.\n    \"\"\"\n    args = arg_nested_mul(expr)\n    # remove sign\n    if len(args) > 1 and sp.Integer(-1) in args:\n        args.remove(sp.Integer(-1))\n    with sp.evaluate(False):\n        expr = sp.Mul(*args)\n    f = sp.fraction(expr, exact=True)\n    return sp.gcd(f[0],f[1]) == 1 and f[1] > 0\n\n\ndef is_complex_cartesian(expr):\n    \"\"\"\n    Check if a complex number is in cartesian form.\n    \n    >>> z = sp.sympify(\"I * (2 + I)\", evaluate=False)\n    >>> is_complex_cartesian(z)\n    False\n\n    >>> z = sp.sympify(\"(1 + sqrt(2)) * I + 1 - sqrt(3)\", evaluate=False)\n    >>> is_complex_cartesian(z)\n    True\n    \n    >>> z = sp.sympify(\"I + sqrt(2) * I\", evaluate=False)\n    >>> is_complex_cartesian(z)\n    False\n    \"\"\"\n    args = arg_nested_add(expr)\n    ni = [is_coeff_mul(a, sp.I) for a in args].count(True)\n    nr = [a.is_real for a in args].count(True)\n    return ni <= 1 and ni + nr == len(args)\n\ndef complex_cartesian_parts(expr):\n    \"\"\"\n    Return the real and imaginary parts.\n    \n    >>> z = sp.sympify(\"(1 + sqrt(2)) * I + 1 - sqrt(3)\", evaluate=False)\n    >>> complex_cartesian_parts(z)\n    (-sqrt(3) + 1, 1 + sqrt(2))\n    \n    >>> z = sp.sympify(\"1 + sqrt(2)\", evaluate=False)\n    >>> complex_cartesian_parts(z)\n    (1 + sqrt(2), 0)\n    \n    >>> z = sp.sympify(\"I\", evaluate=False)\n    >>> complex_cartesian_parts(z)\n    (0, 1)\n    \"\"\"\n    args = arg_nested_add(expr)\n    im = next((coeff_mul(a, sp.I) for a in args if is_coeff_mul(a, sp.I)), 0)\n    lstre = [a for a in args if a.is_real]\n    if len(lstre) == 0:\n        re = sp.Integer(0)\n    elif len(lstre) == 1:\n        re = lstre[0]\n    else:\n        with sp.evaluate(False):\n            re = sp.Add(*lstre)\n    return (re, im)\n\n\ndef is_e_i_theta(expr):\n    \"\"\"\n    Check if a complex number is an exponential.\n    \"\"\"\n    if type(expr)==sp.exp:\n        return is_coeff_mul(expr.args[0],sp.I)\n    elif type(expr)==sp.Pow and expr.args[0]==sp.E:\n        return is_coeff_mul(expr.args[1],sp.I)\n    return False\n\ndef is_complex_exponential(expr):\n    \"\"\"\n    Check if a complex number is in exponential form.\n    \"\"\"\n    args=arg_nested_mul(expr)\n    if is_e_i_theta(args[-1]):\n        for a in args[:-1]:\n            if not a.is_real or not a>0:\n                return False\n        return True\n    return False\n\ndef is_poly_expanded(expr, x):\n    \"\"\"\n    Check if a polynomial is expanded.\n    \n    >>> x = sp.Symbol('x')\n    >>> is_poly_expanded(x * (x + 1), x)\n    False\n    \n    >>> is_poly_expanded(x + x**2 + 3*x, x)\n    True\n    \"\"\"\n    args = arg_nested_add(expr)\n    return all(is_coeff_exponent(a,x) for a in args)\n\n    \ndef is_poly_ratsimp(expr, x):\n    \"\"\"\n    Check if a polynomial is expanded.\n    \n    >>> x = sp.Symbol('x')\n    >>> P = sp.sympify(\"x + x**2 + 3*x\", evaluate=False)\n    >>> is_poly_ratsimp(P, x)\n    False\n    \n    >>> P = sp.sympify(\"1 + x**2 + 3*x\", evaluate=False)\n    >>> is_poly_ratsimp(P, x)\n    True\n    \n    >>> P = sp.sympify(\"3*(x**2 + 2)**2\", evaluate=False)\n    >>> is_poly_ratsimp(P, x)\n    True\n    \"\"\"\n    args = arg_nested_mul(expr)\n    for a in args:\n        if type(a) == sp.Pow:\n            a = a.args[0]\n        with sp.evaluate(False):\n            coeffs = sp.Poly(a, x).coeffs()\n        if not all(is_rat_simp(c) for c in coeffs):\n            return False\n    return True\n\ndef is_poly_factorized(expr, x, domain='R'):\n    \"\"\"\n    Check if a polynomial is factorized.\n\n    >>> x = sp.Symbol('x')\n    >>> is_poly_factorized(x**2 - 1, x)\n    False\n\n    >>> is_poly_factorized(-(x**2 + 1) * (2*x - 1)**3, x)\n    True\n    \n    >>> is_poly_factorized(3 * (x**2 - 1) * (- x - 1), x)\n    False\n    \n    >>> is_poly_factorized(x**2 + 1, x, domain='C')\n    False\n    \"\"\"\n    if domain == 'C':\n        kwargs = {'extension': [sp.I]}\n    else:\n        kwargs = {'domain': domain}\n        \n    args = arg_nested_mul(expr)\n    for a in args:\n        if type(a) == sp.Pow:\n            exponent = a.args[1]\n            if exponent.is_Integer and exponent > 0:\n                a = a.args[0]\n            else:\n                return False\n        if not sp.Poly(a, x, **kwargs).is_irreducible:\n            return False\n    return True\n\ndef simplify_rset(lst):\n    \"\"\"\n    Simplify endpoint in a list of intervals.\n    \"\"\"\n    for i, interv in enumerate(lst):\n        left = sp.simplify(interv.left)\n        right = sp.simplify(interv.right)\n        lst[i] =  sp.Interval(left, right, interv.left_open, interv.right_open)\n    return lst\n\ndef func_in_expr(expr):\n    \"\"\"\n    Return the functions involved in an expression.\n    \n    >>> expr = sp.sympify(\"sin(p/3)\", evaluate=False)\n    >>> func_in_expr(expr)\n    {sin}\n    \n    >>> expr = sp.sympify(\"x + sin(x)**2 * cos(x)\", evaluate=False)\n    >>> func_in_expr(expr)\n    {sin, cos}\n    \n    >>> expr = sp.sympify(\"sqrt(ln(1 + x**2))\", evaluate=False)\n    >>> func_in_expr(expr)\n    {log}\n    \"\"\"\n    return set([type(a) for a in expr.atoms(sp.Function)])\n\n\n# Answer evaluation functions\n\n_feedback_ = {\n\"Success\": \"\",\n\"NotEqual\": \"\",\n\"NotExpr\": \"La r\u00e9ponse doit \u00eatre une expression math\u00e9matique.\",\n\"NotRealOrInf\": \"La r\u00e9ponse doit \u00eatre un nombre r\u00e9el ou $! +\\infty !$ ou $! -\\infty !$.\",\n\"NotRSet\": \"La r\u00e9ponse doit \u00eatre un intervalle ou une r\u00e9union d'intervalles.\",\n\"NotCplx\": \"La r\u00e9ponse doit \u00eatre un nombre complexe.\",\n\"NotCplxCartesian\": \"La r\u00e9ponse doit \u00eatre un nombre complexe sous forme cart\u00e9sienne.\",\n\"NotCplxExponential\": \"La r\u00e9ponse doit \u00eatre un nombre complexe sous forme exponentielle.\",\n\"NotSet\": \"La r\u00e9ponse doit \u00eatre un ensemble.\",\n\"NotTuple\": \"La r\u00e9ponse doit \u00eatre un n-uplet (un vecteur ligne).\",\n\"NotPoly\": \"La r\u00e9ponse doit \u00eatre un polyn\u00f4me.\",\n\"NotPhysical\": \"La r\u00e9ponse doit \u00eatre une valeur num\u00e9rique suivie d'une unit\u00e9 physique.\",\n\"PhysicalNotNumeric\": \"La partie num\u00e9rique doit \u00eatre un nombre d\u00e9cimal.\",\n\"WrongUnit\": \"Mauvaise unit\u00e9.\",\n\"RSetNotDisjoint\": \"Les ensembles de cette r\u00e9union ne sont pas disjoints. La r\u00e9ponse peut \u00eatre simplifi\u00e9e.\",\n\"PolyNotExpanded\": \"La r\u00e9ponse doit \u00eatre un polyn\u00f4me d\u00e9velopp\u00e9.\",\n\"PolyNotFactorized\": \"La r\u00e9ponse doit \u00eatre un polyn\u00f4me factoris\u00e9.\",\n\"MatWrongSize\": \"La matrice n'a pas la bonne taille.\",\n\"NotRatSimp\": \"L'expression peut encore \u00eatre simplifi\u00e9e.\",\n\"Duplicates\": \"Il y a des doublons dans l'ensemble.\",\n\"UnauthorizedFunc\": \"Votre r\u00e9ponse utilise des fonctions non-autoris\u00e9es.\"\n}\n\ndef add_feedback(eval):\n    def eval_with_feedback(*args, **kwargs):\n        if 'dictfeedback' in kwargs:\n            feedback = {**_feedback_, **kwargs['dictfeedback']}\n            kwargs.pop('dictfeedback')\n        else:\n            feedback = _feedback_\n        score, error = eval(*args, **kwargs)\n        if error in _feedback_:\n            return score, error, feedback[error]\n        else:\n            return score, error, \"\"\n    return eval_with_feedback\n\ndef eval_expr(strans, sol, checkratsimp=True, authorized_func=None, local_dict={}):\n    r\"\"\"\n    Evaluate an answer when the solution is an expression.\n    \n    >>> expr = sp.sympify(\"sqrt(2)/2\", evaluate=False)\n    >>> eval_expr(r\"\\frac{1}{\\sqrt{2}}\", expr)[1]\n    'Success'\n    \n    >>> eval_expr(r\"\\frac{\\sqrt{2}}{2}\", expr)[1]\n    'Success'\n    \n    >>> eval_expr(r\"\\sin(\\pi/4)\", expr)[1]\n    'Success'\n    \n    >>> eval_expr(r\"\\sin(\\pi/4)\", expr, authorized_func={})[1]\n    'UnauthorizedFunc'\n    \n    >>> eval_expr(\"e\", sp.E)[1]\n    'NotEqual'\n    \n    >>> eval_expr(\"\\exp(1)\", sp.E)[1]\n    'Success'\n    \n    >>> eval_expr(\"\\exp(1)\", sp.E, local_dict={'e': sp.E})[1]\n    'Success'\n    \"\"\"\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1, \"NotExpr\")\n    if not isinstance(ans, sp.Expr):\n        return (-1, \"NotExpr\")\n    if authorized_func is not None and not func_in_expr(ans).issubset(authorized_func):\n        return (-1, \"UnauthorizedFunc\")\n    if not equal(ans, sol):\n        return (0, \"NotEqual\")\n    if checkratsimp and not is_rat_simp(ans):\n        return (-1, \"NotRatSimp\")\n    return (100, \"Success\")\n\ndef eval_frac(strans, sol, simpwarning=True):\n    \"\"\"\n    Evaluate an answer when the solution is a fraction.\n    \"\"\"\n    try:\n        ans = latex2sympy(strans)\n    except:\n        return (-1, \"NotFrac\")\n    if not isinstance(ans, sp.Expr):\n        return (-1, \"NotFrac\")\n    if not is_frac_int(ans):\n        return (-1, \"NotFrac\")\n    if not equal(ans, sol):\n        return (0, \"NotEqual\")\n    if not is_frac_irred(ans):\n        if simpwarning:\n            return (-1, \"NotRatSimp\")\n        else:\n            return (0, \"NotRatSimp\")\n    return (100, \"Success\")\n\ndef eval_function(strans, sol, checkratsimp=True, authorized_func=None, local_dict={}):\n    r\"\"\"\n    Evaluate an answer when the solution is a function.\n    \"\"\"\n    local_dict.update({'e': sp.E})\n    return eval_expr(strans, sol, checkratsimp, authorized_func, local_dict)\n\n@add_feedback\ndef eval_real_or_inf(strans, sol, local_dict={}):\n    \"\"\"\n    Evaluate an answer when the solution is real or equal to infinity.\n    \"\"\"\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1, \"NotRealOrInf\")\n    if not isinstance(ans, sp.Expr) or not is_real_or_inf(ans):\n        return (-1, \"NotRealOrInf\")\n    if not equal(ans, sol):\n        return (0, \"NotEqual\")\n    return (100, \"Success\")\n\n\n@add_feedback\ndef eval_complex(strans, sol, imaginary_unit=\"i\", form=\"\", checkratsimp=True, authorized_func={}, local_dict={}):\n    \"\"\"\n    Evaluate an answer when the solution is a complex number.\n    \"\"\"\n    local_dict.update({imaginary_unit: sp.I, 'e': sp.E})\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1, \"NotCplx\")\n    if not isinstance(ans, sp.Expr) or not ans.is_complex:\n        return (-1, \"NotCplx\")\n    if authorized_func is not None and not func_in_expr(ans).issubset(authorized_func):\n        return (-1, \"UnauthorizedFunc\")\n    if not equal(ans, sol):\n        return (0, \"NotEqual\")\n    if form == \"cartesian\":\n        if not is_complex_cartesian(ans):\n            return (-1, \"NotCplxCartesian\")\n        if checkratsimp and any(not is_rat_simp(part) for part in complex_cartesian_parts(ans)):\n            return (-1, \"NotRatSimp\")\n    if form == \"exponential\" and not is_complex_exponential(ans):\n            return (-1, \"NotCplxExponential\")\n    return (100, \"Success\")\n\ndef eval_poly(strans, sol, var='x', domain='R', form='', checkratsimp=True, imaginary_unit='i',  authorized_func={}, local_dict={}):\n    \"\"\"\n    Evaluate an answer when the solution is a polynomial.\n    \n    >>> x = sp.Symbol('x')\n    >>> P = (x + 1)**2\n    \n    >>> eval_poly(\"x^2 + 2x + 1\", P, form=\"expanded\")[1]\n    'Success'\n    \n    >>> eval_poly(\"(x + 1)^2\", P, form=\"factorized\")[1]\n    'Success'\n    \n    >>> eval_poly(\"(x + 1)^2\", P, form=\"expanded\")[1]\n    'PolyNotExpanded'\n    \n    >>> eval_poly(\"x^2 + 2x + 1\", P, form=\"factorized\")[1]\n    'PolyNotFactorized'\n    \"\"\"\n    x = sp.Symbol(var)\n    local_dict.update({imaginary_unit: sp.I, var: x})\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1, \"NotPoly\")\n    if not isinstance(ans,sp.Expr) or not ans.is_polynomial(x):\n        return (-1, \"NotPoly\")\n    if form == \"expanded\" and not is_poly_expanded(ans ,x):\n        return (-1, \"PolyNotExpanded\")\n    elif form == \"factorized\" and not is_poly_factorized(ans, x, domain):\n        return (-1, \"PolyNotFactorized\")\n    if not equal(ans,sol):\n        return (0, \"NotEqual\")\n    if checkratsimp and not is_poly_ratsimp(ans, x):\n        return (-1, \"PolyNotRatSimp\")\n    return (100, \"Success\")\n\ndef eval_set(strans, sol, checkratsimp=True, local_dict={}):\n    \"\"\"\n    Evaluate an answer when the solution is a finite set.\n    \n    >>> A = FiniteSet(1, 3, 5)\n    \n    >>> eval_set(\"\\{5,1,3\\}\", A)\n    (100, 'Success')\n    \n    >>> eval_set(\"(5,1,3)\", A)\n    (-1, 'NotSet')\n    \n    >>> eval_set(\"\\{5,1,3,1\\}\", A)\n    (-1, 'Duplicates')\n    \n    >>> eval_set(\"\\{5,3\\}\", A)\n    (0, 'NotEqual')\n    \n    >>> eval_set(\"\\{5,1,1+2\\}\", A)\n    (-1, 'NotRatSimp')\n    \"\"\"\n    sol = FiniteSet2struct(sol)\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1, \"NotSet\")\n    if not isinstance(ans, list):\n        return (-1, \"NotSet\")\n    if duplicates(ans):\n        return (-1, \"Duplicates\")\n    if not equal_struct(ans, sol):\n        return (0, \"NotEqual\")\n    if checkratsimp and not is_rat_simp(ans):\n        return (-1, \"NotRatSimp\")\n    return (100, \"Success\")\n\n@add_feedback\ndef eval_tuple(strans, sol, checksize=False, local_dict={}):\n    \"\"\"\n    Evaluate an answer when the solution is a tuple/vector.\n    \"\"\"\n    sol = tuple(sol)\n    try:\n        ans = latex2sympy(strans, local_dict)\n    except:\n        return (-1,\"NotTuple\")\n    if not isinstance(ans,tuple):\n        return (-1,\"NotTuple\")\n    if checksize and len(ans) != len(sol):\n        return (-1, \"TupleWrongSize\")\n    if not equal_struct(ans,sol):\n        return (0, \"NotEqual\")\n    return (100, \"Success\")\n\n@add_feedback\ndef eval_matrix(matans, sol):\n    \"\"\"\n    Evaluate an answer when the solution is a matrix.\n    \"\"\"\n    try:\n        ans = sp.Matrix(matans)\n    except:\n        return (-1, \"NotMat\")\n    if ans.shape != sol.shape:\n        return (0, \"MatWrongSize\")\n    if not ans.equals(sol):\n        return (0, \"NotEqual\")\n    return (100, \"Success\")\n\n@add_feedback\ndef eval_rset(strans, sol):\n    \"\"\"\n    Evaluate an answer when the solution is an union of intervals.\n    \"\"\"\n    try:\n        ans = latex2rset(strans)\n        # simplification of endpoints is needed\n        # otherwise, Sympy struggles to compare intervals\n        # even with simplification, not sure comparison always works\n        ans = simplify_rset(ans)\n    except:\n        return (-1, \"NotRSet\")\n    if len(ans) > 1:\n        for i in range(len(ans)):\n            for j in range(i+1,len(ans)):\n                if sp.Intersection(ans[i], ans[j]) != sp.EmptySet:\n                    return (-1, \"RSetNotDisjoint\")\n    if sp.Union(*ans) != sol:\n        return (0, \"NotEqual\")\n    return (100,\"\")\n\nfrom sympy.physics.units import Quantity, convert_to\n\ndef get_numeric_unit(expr):\n    \"\"\"\n    Return the numerical part and the unit of a physical quantity.\n    \"\"\"\n    args = arg_nested_mul(expr)\n    args_numeric = []\n    args_quantity = []\n    for a in args:\n        if isinstance(a, sp.Pow):\n            if isinstance(a.base, Quantity):\n                args_quantity.append(a)\n            else:\n                args_numeric.append(a)\n        elif isinstance(a, Quantity):\n            args_quantity.append(a)\n        else:\n            args_numeric.append(a)\n    return (sp.Mul(*args_numeric), sp.Mul(*args_quantity))\n\nfrom sympy.physics.units.systems.si import dimsys_SI, SI\n\n@add_feedback\ndef eval_physical(strans, sol, tol, local_dict={}):\n    r\"\"\"\n    Evaluate an answer when the solution is a physical quantity.\n    \"\"\"\n    numsol, unitsol = get_numeric_unit(sol)\n    dimsol = dimsys_SI.get_dimensional_dependencies(SI.get_dimensional_expr(unitsol))\n    try:\n        ans = latex2sympy(strans, local_dict)\n        num, unit = get_numeric_unit(ans)\n        dim = dimsys_SI.get_dimensional_dependencies(SI.get_dimensional_expr(unit))\n    except:\n        return (-1, \"NotPhysical\")\n    if unit==1:\n        return (-1, \"NotPhysical\")\n    if not (num.is_Float or num.is_Integer):\n        return (-1, \"PhysicalNotNumeric\")\n    if dim != dimsol:\n        return (0, \"WrongUnit\")\n    num, unit = get_numeric_unit(convert_to(ans,unitsol))\n    if not equal_approx(numsol, num, tol=tol):\n        return (0, \"NotEqual\")\n    return (100, \"Success\")\n\ndef ans_antiderivative(strans,sol,x,local_dict={}):\n    \"\"\"\n    Analyze an answer of type expr.\n    \"\"\"\n    x=sp.Symbol('x')\n    test1=[(is_expr,-1,\"NotExpr\",\"Votre r\u00e9ponse n'est pas une expression valide.\")]\n    test2=[]\n    test2.append((is_rat_simp,-1,\"NotRatSimp\",\"L'expression peut encore \u00eatre simplifi\u00e9e.\"))\n    return ans_eqconstant_(strans,sol,x,local_dict,test1,test2)\n\n\n\n\n",
    "latex2sympy.py":"import sympy as sp\nimport sympy.parsing.sympy_parser as prs\nimport re\n\n\ndef str2sympy(s, local_dict={}, evaluate=False):\n    \"\"\"\n    Convert a string into an expression or a nested structure of\n    lists and tuples of expressions.\n\n    >>> str2sympy(\"x+3+2x\")\n    x + 2*x + 3\n    \n    >>> str2sympy(\"2^3\")\n    2**3\n    \n    >>> str2sympy(\"sin 2 pi\")\n    sin(2*pi)\n    \n    >>> str2sympy(\"3!\")\n    factorial(3)\n    \n    >>> str2sympy(\"1+i\",{'i':sp.I})\n    1 + I\n    \n    >>> str2sympy(\"{0, pi, 2 pi}\")\n    [0, pi, 2*pi]\n    \"\"\"\n    s.strip()\n    \n    if s == \"\":\n        return None\n\n    s = s.replace(\"{\", \"[\")\n    s = s.replace(\"}\", \"]\")\n    \n    global_dict = {}\n    exec('from sympy import *', global_dict, global_dict)\n    global_dict.update(local_dict)\n    transformations=prs.standard_transformations + (prs.implicit_multiplication_application,prs.convert_xor)\n    #transformations = (prs.standard_transformations + (prs.implicit_multiplication_application,))\n    return prs.parse_expr(s,global_dict=global_dict,transformations=transformations,evaluate=evaluate)\n\ndef latex2str(s):\n    r\"\"\"\n    Convert a LaTeX string into a SymPy-readable string.\n\n    >>> latex2str(\"e^{i \\pi}\")\n    'e^(i  pi)'\n        \n    >>> latex2str(\"-\\infty\")\n    '-oo'\n    \n    >>> latex2str(r\"\\frac{\\pi}{4}\")\n    '( pi)/(4)'\n    \n    >>> latex2str(r\"\\left\\{0, \\frac{1}{2} \\right\\}\")\n    '{0, (1)/(2) }'\n    \"\"\"\n    \n    # delete meaningless substrings\n    lst=[r\"\\mleft\", r\"\\mright\", r\"\\left\", r\"\\right\"]\n    for s1 in lst:\n        s = s.replace(s1, \"\")\n    \n    # replace \\frac{}{}\n    #pattern = re.compile(r'^(.*)\\\\frac\\s*{((?:(?!frac).)*)}{((?:(?!frac).)*)}(.*)$')\n    #while pattern.search(s) is not None:\n    #    s = pattern.sub(r\"\\1(\\2)/(\\3)\\4\", s)\n\n    # replace some substrings\n    lst=[(r\"\\frac\",\"\"),\n         (r\"}{\", \")/(\"),\n         (r\"} {\", \")/(\"),\n         (r\"\\{\",r\"\\lbrace\"),\n         (r\"\\}\",r\"\\rbrace\"),\n         (\"{\", \"(\"),\n         (\"}\", \")\"),\n         (r\"\\operatorname\",\" \"),\n         (r\"\\lbrace\",\"{\"),\n         (r\"\\rbrace\",\"}\"),\n         (r\"\\infty\", \"oo\"),\n         (r\"\\times\", \"*\"),\n         (r\"\\cdot\", \"*\"),\n         (r\"\\arccos\", \"acos\"),\n         (r\"\\arcsin\", \"asin\"),\n         (r\"\\arctan\", \"atan\"),\n         (r\"\\emptyset\",\"{}\"),\n         (\"\\\\\", \" \")]\n         \n    for (s1,s2) in lst:\n        s = s.replace(s1,s2)\n        \n    return s\n\n\ndef latex2sympy(s, local_dict={}):\n    r\"\"\"\n    Convert a LaTeX string into a SymPy expression without simplification.\n    \"\"\"\n    return str2sympy(latex2str(s), local_dict)\n    \ndef str2interval(s, notation=\"bracket\", local_dict={}):\n    \"\"\"\n    Convert a string into an interval.\n    \n    >>> str2interval(\"[3,4]\")\n    Interval(3, 4)\n    \n    >>> str2interval(\"]pi/4,pi/2]\")\n    Interval.Lopen(pi/4, pi/2)\n    \n    >>> str2interval(\"[1,oo[\")\n    Interval(1, oo)\n    \"\"\"\n    # TODO : english notation\n    # TODO : raise error when closed infinity endpoint\n    # TODO : , or ; as separator ?\n    s = s.strip()\n    \n    pattern = re.compile(r'^{(.*)}$')\n    if pattern.search(s) is not None:\n        return sp.FiniteSet(str2sympy(pattern.search(s).group(1)))\n    pattern = re.compile(r'^\\[(.*),(.*)\\]$')\n    \n    if pattern.search(s) is not None:\n        return sp.Interval(str2sympy(pattern.search(s).group(1)),str2sympy(pattern.search(s).group(2)))\n        \n    pattern = re.compile(r'^\\[(.*),(.*)\\[$')\n    if pattern.search(s) is not None:\n        return sp.Interval.Ropen(str2sympy(pattern.search(s).group(1)),str2sympy(pattern.search(s).group(2)))\n        \n    pattern = re.compile(r'^\\](.*),(.*)\\]$')\n    if pattern.search(s) is not None:\n        return sp.Interval.Lopen(str2sympy(pattern.search(s).group(1)),str2sympy(pattern.search(s).group(2)))\n        \n    pattern = re.compile(r'^\\](.*),(.*)\\[$')\n    if pattern.search(s) is not None:\n        return sp.Interval.open(str2sympy(pattern.search(s).group(1)),str2sympy(pattern.search(s).group(2)))\n        \n    raise ValueError()\n    \ndef latex2interval(s, notation=\"bracket\", local_dict={}):\n    \"\"\"\n    Convert a latex string into an interval.\n    \n    >>> latex2interval(\"\\\\left\\\\[3,4\\\\right\\\\]\")\n    Interval(3, 4)\n    \n    >>> latex2interval(\"\\\\left\\]\\\\pi/4,\\\\pi/2\\\\right\\]\")\n    Interval.Lopen(pi/4, pi/2)\n    \n    >>> latex2interval(\"\\\\left\\\\[1,+\\\\infty\\\\right\\\\[\")\n    Interval(1, oo)\n    \"\"\"\n    return str2interval(latex2str(s), notation=notation, local_dict=local_dict)\n    \ndef latex2rset(s, local_dict={}):\n    \"\"\"\n    Convert a latex string into an interval reunion.\n    \n    >>> latex2rset(\"\\emptyset\")\n    [EmptySet()]\n    \"\"\"\n    args = s.split(r\"\\cup\")\n    rset = []\n    for a in args:\n        if a.strip() == r\"\\emptyset\":\n            rset.append(sp.EmptySet)\n        elif a.strip() == r\"\\R\":\n            rset.append(sp.S.Reals)\n        else:\n            rset.append(latex2interval(a))\n    return rset\n\ndef FiniteSet2struct(S):\n    if S == sp.EmptySet:\n        return []\n    elif isinstance(S, (sp.Set, set)):\n        return [FiniteSet2struct(x) for x in S]\n    elif isinstance(S, tuple):\n        return tuple([FiniteSet2struct(x) for x in S])\n    else:\n        return S\n\n\n\n\n",
    "sympy2latex.py":"import sympy as sp\nfrom sympy.printing.latex import LatexPrinter\nfrom sympy.core.compatibility import default_sort_key\n\nclass CustomLatexPrinter(LatexPrinter):\n    \"\"\" \n    A custom LaTeX printer for SymPy objects.\n\n    This printer is based on the standard LaTeX Printer.\n    It overrides some methods and adds some settings.\n    \"\"\"\n    custom_settings = {\n        \"interv_rev_brack\": True\n    }\n\n    def _print_FiniteSet(self, s):\n        \"\"\"\n        Return a LaTeX code for a FiniteSet object.\n\n        Modification : No braces around the elements to deal\n        with the markdown bug.\n        \"\"\"\n        items = sorted(s, key=default_sort_key)\n        items = \", \".join(map(self._print, items))\n        return r\"\\{ %s \\}\" % items\n\n    def _print_Poly(self, poly):\n        \"\"\"\n        Return a LaTeX code for a Poly object.\n\n        Modification : No reference to the polynomial domain.\n        \"\"\"\n        cls = poly.__class__.__name__\n        terms = []\n        for monom, coeff in poly.terms():\n            s_monom = ''\n            for i, exp in enumerate(monom):\n                if exp > 0:\n                    if exp == 1:\n                        s_monom += self._print(poly.gens[i])\n                    else:\n                        s_monom += self._print(pow(poly.gens[i], exp))\n\n            if coeff.is_Add:\n                if s_monom:\n                    s_coeff = r\"\\left(%s\\right)\" % self._print(coeff)\n                else:\n                    s_coeff = self._print(coeff)\n            else:\n                if s_monom:\n                    if coeff is sp.S.One:\n                        terms.extend(['+', s_monom])\n                        continue\n\n                    if coeff is sp.S.NegativeOne:\n                        terms.extend(['-', s_monom])\n                        continue\n\n                s_coeff = self._print(coeff)\n\n            if not s_monom:\n                s_term = s_coeff\n            else:\n                s_term = s_coeff + \" \" + s_monom\n\n            if s_term.startswith('-'):\n                terms.extend(['-', s_term[1:]])\n            else:\n                terms.extend(['+', s_term])\n\n        if terms[0] in ['-', '+']:\n            modifier = terms.pop(0)\n\n            if modifier == '-':\n                terms[0] = '-' + terms[0]\n\n        return ' '.join(terms)\n\n    def _print_Interval(self, i):\n        \"\"\"\n        Return a LaTeX code for an Interval object.\n\n        Modification : Reverse bracket notation for open bounds.\n        \"\"\"\n        if i.start == i.end:\n            return r\"\\left\\{%s\\right\\}\" % self._print(i.start)\n            \n        else:\n            if i.left_open:\n                if self.custom_settings[\"interv_rev_brack\"]:\n                    left = ']'\n                else:\n                    left = '('\n            else:\n                left = '['\n    \n            if i.right_open:\n                if self.custom_settings[\"interv_rev_brack\"]:\n                    right = '['\n                else:\n                    right = ')'\n            else:\n                right = ']'\n    \n            return r\"\\left%s%s, %s\\right%s\" % \\\n                    (left, self._print(i.start), self._print(i.end), right)\n\n\n    def _print_MatrixBase(self, expr):\n        \"\"\"\n        Return a LaTeX code for a Matrix object.\n\n        Modification : No brackets/parentheses to deal\n        with the markdown bug.\n        \"\"\"\n        lines = []\n\n        for line in range(expr.rows):  # horrible, should be 'rows'\n            lines.append(\" & \".join([ self._print(i) for i in expr[line, :] ]))\n\n        mat_str = self._settings['mat_str']\n        if mat_str is None:\n            if self._settings['mode'] == 'inline':\n                mat_str = 'smallmatrix'\n            else:\n                if (expr.cols <= 10) is True:\n                    mat_str = 'matrix'\n                else:\n                    mat_str = 'array'\n\n        out_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n        out_str = out_str.replace('%MATSTR%', mat_str)\n        if mat_str == 'array':\n            out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n        return out_str % r\"\\\\\\\\\".join(lines)\n\ntry:\n    from latex_settings import _default_settings\nexcept ModuleNotFoundError:\n    _default_settings = {\n        'ln_notation': True\n    }\n\ndef latex(expr):\n    \"\"\"\n    Return a LaTeX string for a SymPy object.\n    \"\"\"\n    return CustomLatexPrinter(_default_settings).doprint(expr)\n\ndef latex_linsys(A, B, lstvar=['x','y','z','t','u','v','w']):\n    \"\"\"\n    Return a LaTeX string for a linear system.\n    \"\"\"\n    if not isinstance(A, sp.Matrix):\n        A = sp.Matrix(A)\n    if not isinstance(B, sp.Matrix):\n        B = sp.Matrix(B)\n\n    n, m = A.shape\n    \n    terms = []\n    for i in range(n):\n        terms.extend([\"&\", latex_lincomb(A[i,:], lstvar)])\n        if i < n-1:\n            terms.extend([\"=\", latex(B[i]), \"\\\\\\\\\\\\\"])\n        else:\n            terms.extend([\"=\", latex(B[i])])\n    if n == 1:\n        return \" \".join(terms)\n    else:\n        return \"\\\\left\\lbrace \\\\\\\\begin{align} %s \\\\\\\\end{align} \\\\right. \" % \" \".join(terms) \n\ndef latex_lincomb(coeff, vec):\n    \"\"\"\n    Return a LaTeX string for a linear combination.\n    \"\"\"\n    code=\"\"\n    first=True\n    for i in range(len(coeff)):\n        if coeff[i]!=0:\n            if not first and coeff[i]>0:\n                code+=\"+ \"\n            if coeff[i]==1:\n                code+=vec[i]\n            elif coeff[i]==-1:\n                code+=\"-\"+vec[i]\n            else:\n                code+=latex(coeff[i])+\" \"+vec[i]\n            first=False\n    return code\n\ndef latex_ineq(lst):\n    expr1,rel1,expr,rel2,expr2=lst\n    rel1=rel1.replace(\"<=\",r\"\\le\")\n    rel1=rel1.replace(\">=\",r\"\\ge\")\n    rel2=rel2.replace(\"<=\",r\"\\le\")\n    rel2=rel2.replace(\">=\",r\"\\ge\")\n    return latex(expr1)+rel1+\" \"+latex(expr)+rel2+\" \"+latex(expr2)\n\n\n\n\n",
    "randsympy.py":"import random as rd\nimport sympy as sp\n\ndef randitem(items,excluded_values=[]):\n    \"\"\"\n    Pick a random item from a list.\n    \"\"\"\n    item=rd.choice(items)\n    while item in excluded_values:\n        item=rd.choice(items)\n    return item\n\ndef _list_rand0(n,items,replace,excluded_values):\n    \"\"\"\n    Generate a list of random items selected from a list.\n    \"\"\"\n    if replace==True:\n        lst=[]\n        while len(lst)<n:\n            item=rd.choice(items)\n            if item not in excluded_values:\n                lst.append(item)\n    elif replace==False:\n        m=len(excluded_values)\n        lst=rd.sample(items,n+m)\n        if m>0:\n            lst=[x for x in lst if x not in excluded_values]\n            lst=lst[0:n]\n    else:\n        raise ValueError\n    return lst\n    \ndef list_randitem(n,items,excluded_values=[]):\n    \"\"\"\n    Generate a list of random items selected from a list with replacements.\n    \"\"\"\n    return _list_rand0(n,items,True,excluded_values)\n\ndef list_randitem_norep(n,items,excluded_values=[]):\n    \"\"\"\n    Generate a list of random items selected from a list without replacements.\n    \"\"\"\n    return _list_rand0(n,items,False,excluded_values)\n\n# Integers\n\ndef randint(a,b,excluded_values=[]):\n    \"\"\"\n    Pick a random integer.\n    \"\"\"\n    item=rd.choice(range(a,b+1))\n    while item in excluded_values:\n        item=rd.choice(range(a,b+1))\n    return item\n\ndef list_randint(n,a,b,excluded_values=[]):\n    \"\"\"\n    Generate a list of random integers with replacements.\n    \"\"\"\n    return _list_rand0(n,range(a,b+1),True,excluded_values)\n\ndef list_randint_norep(n,a,b,excluded_values=[]):\n    \"\"\"\n    Generate a list of random integers without replacements.\n    \"\"\"\n    return _list_rand0(n,range(a,b+1),False,excluded_values)\n\n# Complex numbers\n\ndef rand_complex_int(bound):\n    \"\"\"\n    Generate a random complex number with integer coefficients.\n    \"\"\"\n    a,b=list_randint(2,-bound,bound,[0])\n    return sp.sympify(a+b*sp.I)\n\n# Finite sets\n\ndef rand_finiteset(n,items,excluded_values=[]):\n    \"\"\"\n    Generate a random finite set.\n    \"\"\"\n    return sp.FiniteSet(*list_randitem_norep(n,items,excluded_values=[]))\n\ndef rand_set(n,items,excluded_values=[]):\n    \"\"\"\n    Generate a random finite set.\n    \"\"\"\n    return sp.FiniteSet(*list_randitem_norep(n,list(items),excluded_values=[]))\n\n\n# Intervals\n\ndef rand_interval_type(a,b):\n    \"\"\"\n    Generate an interval with random type of bounds.\n    \"\"\"\n    bl=rd.choice([True,False])\n    br=rd.choice([True,False])\n    return sp.Interval(a,b,left_open=bl,right_open=br)\n\n# Polynomials\n\ndef rand_int_poly(d, nc, bound, var='x'):\n    \"\"\"\n    Generate a random polynomial with integer coefficients.\n    \"\"\"\n    x = sp.Symbol(var)\n    c = list_randint(nc, -bound, bound, [0])\n    p = [d] + list_randint_norep(nc-1, 0, d-1)\n    return sum([c[i]*x**p[i] for i in range(nc)])\n\n# Matrices\n\ndef rand_int_matrix(n,p,bound,excluded_values=[],sparsity=0):\n    \"\"\"\n    Generate a random matrix with integer entries.\n    \"\"\"\n    nbzero=int(sp.floor(sparsity*n*p))\n    entries0=[0]*nbzero\n    entries1=list_randint(n*p-nbzero,-bound,bound,excluded_values)\n    entries=entries0+entries1\n    rd.shuffle(entries)\n    return sp.Matrix(n,p,entries)\n\ndef rand_int_matrix_invertible(n,bound,excluded_values=[],sparsity=0,mindet=0,maxdet=sp.S.Infinity):\n    \"\"\"\n    Generate an invertible random matrix with integer entries.\n    \"\"\"\n    while True:\n        M=rand_int_matrix_fullrank(n,n,bound,excluded_values,sparsity)\n        if mindet <= abs(M.det()) <= maxdet:\n            return M\n            \ndef rand_int_matrix_fullrank(n,p,bound,excluded_values=[],sparsity=0):\n    \"\"\"\n    Generate a full rank random matrix with integer entries.\n    \"\"\"\n    while True:\n        M=rand_int_matrix(n,p,bound,excluded_values,sparsity)\n        if M.rank()==min([n,p]):\n            return M\n\ndef rand_int_matrix_givenrank(n,m,r,magnitude=2):\n    \"\"\"\n    Generate a nxn random matrix with given rank.\n    \"\"\"\n    A=sp.zeros(n,m)\n    d=list_randint_norep(r,0,n-1)\n    for i in range(r):\n        A[d[i],d[i]]=1\n    while True:\n        P=rand_int_matrix_invertible(n,magnitude)\n        Q=rand_int_matrix_invertible(m,magnitude)\n        B=P*A*Q\n        numzeros=0\n        for i in range(n):\n            for j in range(m):\n                if B[i,j]==0:\n                    numzeros += 1\n        diffrows=len(set([tuple(B.row(i)) for i in range(n)]))\n        diffcols=len(set([tuple(B.col(i)) for i in range(n)]))\n        if numzeros < n and diffcols==n and diffrows==n:\n            return P*A*Q\n\n\n\n\n",
    "plmpl.py":"import matplotlib.pyplot as plt\nfrom io import BytesIO, StringIO\nimport base64\n\n\ndef fig2base64(fig, format='png', transparent=True, **kwargs):\n    file = BytesIO()\n    fig.savefig(file, format=format, transparent=transparent, **kwargs)\n    return base64.b64encode(file.getvalue()).decode('ascii')\n\ndef fig2svg(fig, transparent=True, **kwargs):\n    file = StringIO()\n    fig.savefig(file, format='svg', transparent=transparent, **kwargs)\n    width, height = fig.get_size_inches()\n    width, height = 72*width, 72*height\n    lines = file.getvalue().splitlines()\n    for i, line in enumerate(lines):\n        if line.startswith('<svg'):\n            lines[i] = \"<svg viewBox='0 0 %s %s'>\" % (width, height)\n            break\n\n    return \"\\n\".join(lines)\n\n\ndef short_float_fmt(x):\n    \"\"\"\n    Create a short string representation of a float, which is %f\n    formatting with trailing zeros and the decimal point removed.\n    \"\"\"\n    return '{0:f}'.format(x).rstrip('0').rstrip('.')\n",
    "plrandom.py":"import random\nrd = random.Random()\n\n\n\n",
    "keyboards.JSON":"{\n    \"virtualKeyboardTheme\": \"material\",\n    \"smartFence\": false,\n    \"inlineShortcuts\": {\n      \"*\": \"\\\\times\",\n      \"<\": \"<\"\n    },\n    \"virtualKeyboardMode\": \"manual\",\n    \"virtualKeyboards\": \"elementary functions complexes sets relations\",\n    \"customVirtualKeyboards\": {\n      \"elementary\": {\n        \"label\": \"El\u00e9mentaire\",\n        \"tooltip\": \"El\u00e9mentaire\",\n        \"layer\": \"elementary\"\n      },\n      \"complexes\": {\n        \"label\": \"Complexes\",\n        \"tooltip\": \"Complexes\",\n        \"layer\": \"complexes\"\n      },\n      \"json\": {\n        \"label\": \"Complexes\",\n        \"tooltip\": \"Complexes\",\n        \"layer\": \"json\"\n      },\n      \"relations\": {\n        \"label\": \"Relations\",\n        \"tooltip\": \"Relations\",\n        \"layer\": \"relations\"\n      },\n      \"sets\": {\n        \"label\": \"Ensembles\",\n        \"tooltip\": \"Ensembles\",\n        \"layer\": \"sets\"\n      },\n      \"functions\": {\n        \"label\": \"Fonctions\",\n        \"tooltip\": \"Fonctions\",\n        \"layer\": \"functions\"\n      },\n      \"electronics\": {\n        \"label\": \"Electronique\",\n        \"tooltip\": \"Electronique\",\n        \"layer\": \"electronics\"\n      }\n    },\n    \"customVirtualKeyboardLayers\": {\n      \"json\": {\n              \"styles\": \"div.ML__keyboard div.json-backdrop > div > div > ul> li.keycap.btn{color:#fff;background:#37454F;border: 1px solid #37454F}\",\n              \"backdrop\": \"json-backdrop\",\n              \"container\": \"json-container\",\n              \"rows\": [\n                  [\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"7\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"8\"\n                      },\n                      {\n                          \"class\": \"fnbutton\",\n                          \"label\": \"9\"\n                      },\n                      {\n                          \"class\": \"keycap btn\",\n                          \"insert\": \"\\\\frac{#0}{#?}\",\n                          \"label\": \"&divide;\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"italic\"\n                      },\n                      {\n                          \"class\": \"separator w20\"\n                      }\n                  ],\n                  [\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"4\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"5\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"6\"\n                      },\n                      {\n                          \"class\": \"keycap btn\",\n                          \"insert\": \"\\\\times \",\n                          \"latex\": \"\\\\times \"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"bold\"\n                       },\n                      {\n                          \"class\": \"separator w20\"\n                      }\n                  ],\n                  [\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"1\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"2\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"label\": \"3\"\n                      },\n                      {\n                          \"class\": \"keycap btn\",\n                          \"label\": \"-\"\n                      },\n                      {\n                          \"class\": \"separator w15\"\n                      },\n                      {\n                          \"class\": \"action font-glyph bottom right w15\",\n                          \"command\": \"deletePreviousChar\",\n                          \"label\": \"&#x232b;\"\n                      }\n                  ],\n                  [\n                      {\n                          \"class\": \"keycap\",\n                          \"insert\": \"\",\n                          \"key\": \"0\",\n                          \"command\": \"\",\n                          \"label\": \"0\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"insert\": \"\",\n                          \"key\": \"\",\n                          \"command\": \"\",\n                          \"label\": \".\"\n                      },\n                      {\n                          \"class\": \"keycap\",\n                          \"insert\": \"\\\\pi \",\n                          \"key\": \"\",\n                          \"command\": \"\",\n                          \"label\": \"<span>\u03c0</span>\"\n                      },\n                      {\n                          \"class\": \"keycap btn\",\n                          \"label\": \"+\"\n                      },\n                      {\n                          \"class\": \"action\",\n                          \"command\": \"moveToPreviousChar\",\n                          \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n                      },\n                      {\n                          \"class\": \"action\",\n                          \"command\": \"moveToNextChar\",\n                          \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n                      },\n                      {\n                          \"class\": \"action\",\n                          \"command\": \"moveToNextPlaceholder\",\n                          \"label\": \"<svg><use xlink:href='#svg-tab' /></svg>\"\n                      }\n                  ]\n              ]\n          },\n      \"elementary\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"x\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"y\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \",\"\n            },\n            {\n                \"class\": \"action font-glyph bottom right w20\",\n                \"command\": \"deletePreviousChar\",\n                \"label\": \"&#x232b;\"\n            }\n          ]\n        ]\n      },\n      \"complexes\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"e\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"i\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \",\"\n            },\n            {\n                \"class\": \"action font-glyph bottom right w20\",\n                \"command\": \"deletePreviousChar\",\n                \"label\": \"&#x232b;\"\n            }\n          ]\n        ]\n      },\n      \"relations\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"latex\": \"\\\\leq\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"latex\": \"<\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"x\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"y\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"latex\": \"\\\\geq\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"latex\": \"=\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"latex\": \">\"\n            },\n            {\n                \"class\": \"action font-glyph bottom right w20\",\n                \"command\": \"deletePreviousChar\",\n                \"label\": \"&#x232b;\"\n            }\n          ]\n        ]\n      },\n      \"sets\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\R\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\emptyset\",\n              \"label\": \"\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"[\",\n              \"label\": \"[\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"]\",\n              \"label\": \"]\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\cup\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\setminus\",\n              \"label\": \"\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\{\",\n              \"label\": \"{\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\}\",\n              \"label\": \"}\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \",\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"-\\\\infty\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"+\\\\infty\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"action font-glyph bottom right w20\",\n              \"command\": \"deletePreviousChar\",\n              \"label\": \"\u232b\"\n            }\n          ]\n        ]\n      },\n      \"functions\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"-\\\\infty\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"+\\\\infty\",\n              \"label\": \"\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\ln\",\n              \"label\": \"ln\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\exp\",\n              \"label\": \"exp\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"x\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"y\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\sin\",\n              \"label\": \"sin\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\cos\",\n              \"label\": \"cos\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \",\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\tan\",\n              \"label\": \"tan\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"e\"\n            },\n            {\n              \"class\": \"action font-glyph bottom right w20\",\n              \"command\": \"deletePreviousChar\",\n              \"label\": \"\u232b\"\n            }\n          ]\n        ]\n      },\n      \"electronics\": {\n        \"rows\": [\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"7\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"8\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"9\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"/\",\n              \"label\": \"/\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\frac{#0}{#?}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"(\",\n              \"label\": \"(\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \")\"\n            },\n            {\n              \"class\": \"separator w10\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"4\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"5\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"6\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\times \",\n              \"latex\": \"\\\\times \"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"insert\": \"\\\\sqrt{#0}\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"e\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"j\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\omega\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"label\": \"1\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"2\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"label\": \"3\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"-\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"command\": \"moveToSuperscript\",\n              \"label\": \"^\"\n            },\n            {\n              \"class\": \"separator w10\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToPreviousChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-left' /></svg>\"\n            },\n            {\n                \"class\": \"action\",\n                \"command\": \"moveToNextChar\",\n                \"label\": \"<svg><use xlink:href='#svg-arrow-right' /></svg>\"\n            }\n          ],\n          [\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"0\",\n              \"command\": \"\",\n              \"label\": \"0\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \".\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \"\\\\pi \",\n              \"key\": \"\",\n              \"command\": \"\",\n              \"label\": \"\"\n            },\n            {\n              \"class\": \"keycap btn\",\n              \"label\": \"+\"\n            },\n            {\n              \"class\": \"keycap\",\n              \"insert\": \",\"\n            },\n            {\n              \"class\": \"separator w10\"\n            },\n            {\n                \"class\": \"action font-glyph bottom right w20\",\n                \"command\": \"deletePreviousChar\",\n                \"label\": \"&#x232b;\"\n            }\n          ]\n        ]\n      }\n    }\n  }\n\n\n\n\n\n\n\n\n",
    "custommathmatrix.py":"from components import Component\nfrom sympy import Matrix\n\nclass CustomMathMatrix(Component):\n\n    def __init__(self, **kwargs):\n        self.selector = 'c-math-matrix'\n        self.decorator = 'CustomMathMatrix'\n        super().__init__(**kwargs)\n\n    def setmatrix(self, M):\n        \"\"\"\n        Set a matrix.\n        \"\"\"\n        self.matrix = []\n        if isinstance(M, list):\n            for row in M:\n                self.matrix.append([{'value': str(value)} for value in row])\n        elif isinstance(M, Matrix):\n            for i in range(len(M.col(0))):\n                self.matrix.append([{'value': str(value)} for value in M.row(i)])\n\n    def getmatrix(self):\n        \"\"\"\n        Set a matrix.\n        \"\"\"\n        return [[item['value'] for item in row] for row in self.matrix]\n        \n",
    "builder.py":"import sys, json\nfrom components import Component\nfrom builderlib import aux_component\nfrom builderlib import PickleEncoder, ComponentEnv\n\n# Import the custom JSON encoder\ntry:\n    from json_encoder import CustomEncoder as JSONEncoder\nexcept ModuleNotFoundError:\n    JSONEncoder = PickleEncoder\n\n# Import the custom Jinja environnement\ntry:\n    from jinja_env import CustomEnv as Env\nexcept ModuleNotFoundError:\n    Env = ComponentEnv\n\n# Import the custom namespace\ntry:\n    from namespace import namespace\nexcept ModuleNotFoundError:\n    namespace = {}\n\n\nif __name__ == \"__main__\":\n    \n    # JSON context is loaded\n    with open(sys.argv[1], \"r\") as f:\n        dic = json.load(f)\n    Component.sync_context(dic)\n\n    # the content of namespace is added to dic\n    dic = {**namespace, **dic}\n    \n    if 'before' in dic:\n\n        # execute the script in before key with dic as globals\n        exec(dic['before'], dic)\n        \n        # clean dic from namespace elements\n        exec(\"\", namespace)\n        for key in namespace:\n            if key in dic and dic[key] == namespace[key]:\n                del dic[key]\n\n    # build the key 'extracss' from the content of the key 'style'\n    if 'style' in dic:\n        dic['extracss'] = \"<style> %s </style>\" % \"\\n\".join(reversed(list(dic['style'].values())))\n\n    # HACK for components in lists\n    aux_component(dic)\n\n    if 'settings' not in dic:\n        dic['settings'] = {}\n\n    if 'internals' not in dic:\n        dic['internals'] = {}\n\n    if 'scenario' in dic['settings']:\n        dic['internals']['buttons'] = [\"submit\",\"reroll\"]\n    else:\n        dic['internals']['buttons'] = [\"submit\",\"reroll\"]\n\n    dic['internals']['attempt'] = 1\n\n    for key in ['text', 'form', 'solution']:\n        if key in dic:\n            dic[key] = Env.from_string(dic[key]).render(dic)\n\n    with open(sys.argv[2], \"w+\") as f:\n        json.dump(dic, f, cls=JSONEncoder)\n\n    sys.exit(0)\n\n\n\n",
    "grader.py":"#!/usr/bin/env python3\n# coding: utf-8\n\nimport sys, json, jsonpickle\nfrom components import Component\nfrom builderlib import aux_component1, aux_component2, aux_component\nfrom builderlib import PickleEncoder\n\nfrom jinja2 import Template\n\ntry:\n    from json_encoder import CustomEncoder, CustomDecoder\nexcept ModuleNotFoundError:\n    CustomEncoder = PickleEncoder\n    CustomDecoder = None\n\ntry:\n    from namespace import namespace\nexcept ModuleNotFoundError:\n    namespace = {}\n\ndef format_feedback_rightwrong(score,feedback):\n    tpl=\"\"\"<div class=\"alert {}\"><strong>{}</strong> <br> {}</div>\"\"\"\n    if score==-1:\n        return tpl.format('alert-info','Attention !',feedback)\n    elif score==100:\n        return tpl.format('alert-success','Bonne r\u00e9ponse.',feedback)\n    else:\n        return tpl.format('alert-danger','Mauvaise r\u00e9ponse.',feedback)\n\ndef format_feedback_score(score,feedback):\n    if score==-1:\n        tpl=\"\"\"<div class=\"alert {}\"><strong>{}</strong><br> {}</div>\"\"\"\n        return tpl.format('alert-info',score, feedback)\n    tpl=\"\"\"<div class=\"alert {}\"><strong>Score : {} / 100</strong><br> {}</div>\"\"\"\n    if score==100:\n        return tpl.format('alert-success',score, feedback)\n    elif score==0:\n        return tpl.format('alert-danger',score, feedback)\n    else:\n        return tpl.format('alert-warning',score, feedback)\n\ndef format_feedback_lightscore(score,feedback):\n    if score==-1:\n        tpl=\"\"\"<div class=\"alert {}\"><strong>{}</strong> <br> {}</div>\"\"\"\n        return tpl.format('alert-info',score, feedback)\n    tpl=\"\"\"<div class=\"alert alert-secondary\"><strong>Score : {} / 100 <br> </strong> {}</div>\"\"\"\n    return tpl.format(score,feedback)\n\n\n\nmissing_evaluator_stderr = \"\"\"\\\nThe key 'evaluator' was not found in the context.\nWhen using this grader, the PL must declare a script inside a key 'evaluator'. This script have\naccess to every variable declared in the PL and its 'before' script.\nIt should declare a variable 'grade' which should contain a tuple (int, feedback) where int is the grade between [0, 100].\"\"\"\n\nif __name__ == \"__main__\":\n\n    with open(sys.argv[1], \"r\") as f:\n        dic = json.load(f, cls=CustomDecoder)\n    Component.sync_context(dic)\n\n    dic = {**namespace, **dic}\n\n    aux_component1(dic)\n    \n    if 'evaluator' in dic:\n            code = dic['evaluator']\n    else:\n        print(missing_evaluator_stderr, file=sys.stderr)\n        sys.exit(1)\n\n    exec(code, dic)\n    exec(\"\", namespace)\n    for key in namespace:\n        if key in dic and dic[key] == namespace[key]:\n            del dic[key]\n\n    aux_component2(dic)\n    \n    dic = json.loads(json.dumps(dic, cls=CustomEncoder))\n\n    if 'grade' in dic:\n        score = dic['grade'][0]\n        feedback = dic['grade'][1] + \" \"\n    else:\n        if 'score' in dic:\n            score = dic['score']    \n\n        feedback=\" \"\n        if 'feedback' in dic:\n            feedback = dic['feedback'] + \" \"\n\n    if score >= 0:\n        dic['internals']['attempt'] = dic['internals']['attempt'] + 1\n    \n    if dic['settings']['maxattempt'] is not None:\n        if dic['internals']['attempt'] > dic['settings']['maxattempt']:\n            try:\n                dic['internals']['buttons'].remove('submit')\n            except:\n                pass\n            if score < 100 and 'solution' in dic:\n                feedback += dic['solution']\n    \n    ffeedback = feedback\n    if 'feedback' in dic['settings']:\n        if dic['settings']['feedback']=='rightwrong':\n            ffeedback=format_feedback_rightwrong(score,feedback)\n        elif dic['settings']['feedback']=='score':\n            ffeedback=format_feedback_score(score,feedback)\n        elif dic['settings']['feedback']=='lightscore':\n            ffeedback=format_feedback_lightscore(score,feedback)\n\n    with open(sys.argv[3], \"w+\") as f:\n        json.dump(dic, f)\n    \n    with open(sys.argv[4], \"w+\") as f:\n        print(str(ffeedback), file=f)\n    \n    print(int(score))\n    \n    sys.exit(0)\n\n\n\n\n\n\n",
    "builderlib.py":"from components import Component\nfrom customdragdrop import DragDropGroup\nimport json, jsonpickle\nfrom jinja2 import Environment, BaseLoader\nimport uuid\n\nclass PickleEncoder(json.JSONEncoder):\n    def default(self, obj):\n        return jsonpickle.Pickler(unpicklable=False).flatten(obj)\n\ndef component(l):\n    if isinstance(l,dict):\n        selector = l[\"selector\"]\n        cid = l[\"cid\"]\n    else:\n        selector = l.selector\n        cid = l.cid\n    return \"<%s cid='%s'></%s>\" % (selector, cid, selector)\n\nComponentEnv = Environment(loader=BaseLoader())\nComponentEnv.filters[\"component\"] = component\n\n# HACK for components in lists\n# components in lists are duplicated outside the lists\n# and replaced by dictionaries inside the lists\ndef aux_component(dic):\n    newcomp = []\n    for key in dic:\n        if isinstance(dic[key], list):\n            for i in range(len(dic[key])):\n                item = dic[key][i]\n                if isinstance(item, Component):\n                    name = \"c\" + uuid.uuid4().hex\n                    newcomp.append((name, item))\n                    dic[key][i] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n                else:\n                    break\n        if isinstance(dic[key], DragDropGroup):\n            for k, item in dic[key].labels.items():\n                    name = \"c\" + uuid.uuid4().hex\n                    newcomp.append((name, item))\n                    dic[key].labels[k] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n            for k, item in dic[key].drops.items():\n                    name = \"c\" + uuid.uuid4().hex\n                    newcomp.append((name, item))\n                    dic[key].drops[k] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n\n    for name, comp in newcomp:\n        comp.name = name\n        dic[name] = comp\n\n# HACK for components in lists\n# dictionaries with cid key in lists are replaced\n# by corresponding components\ndef aux_component1(dic):\n    for key in dic:\n        if isinstance(dic[key], list):\n            for i in range(len(dic[key])):\n                item = dic[key][i]\n                if isinstance(item, dict) and 'cid' in item:\n                    name = item['name']\n                    dic[key][i] = dic[name]\n                    dic[key][i].name = name\n        if isinstance(dic[key], dict) and 'serialize' in dic[key] and dic[key]['serialize'] == 'DragDropGroup':\n            for k, item in dic[key]['labels'].items():\n                    name = item['name']\n                    dic[key]['labels'][k] = dic[name]\n                    dic[key]['labels'][k].name = name\n            for k, item in dic[key]['drops'].items():\n                    name = item['name']\n                    dic[key]['drops'][k] = dic[name]\n                    dic[key]['drops'][k].name = name\n\n            dic[key] = DragDropGroup.fromdict(**dic[key])\n\n# HACK for components in lists\n# components in lists are duplicated outside the lists\n# and replaced by dictionaries inside the lists\ndef aux_component2(dic):\n    for key in dic:\n        if isinstance(dic[key], list):\n            for i in range(len(dic[key])):\n                item = dic[key][i]\n                if isinstance(item, Component):\n                    name = item.name\n                    dic[key][i] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n        if isinstance(dic[key], DragDropGroup):\n            for k, item in dic[key].labels.items():\n                    name = item.name\n                    dic[key].labels[k] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n            for k, item in dic[key].drops.items():\n                    name = item.name\n                    dic[key].drops[k] = {\"cid\": item.cid, \"name\": name, \"selector\": item.selector}\n\n\n\n",
    "scoring.py":"from scipy.stats import kendalltau\n\n_doc_=\"\"\"\nright : number of items filled in with a right answer\nwrong : number of items filled in with a wrong answer\nitems_to_fill : number of items to be filled in\nitems_total : total number of items\n\"\"\"\n\n\ndef all_or_nothing(right, wrong, items_to_fill, items_total=None):\n    return 100 if right == items_to_fill and wrong == 0 else 0\n\ndef right_minus_wrong(nbright=0, nbwrong=0, nbsol=1, nbitems=1):\n    return int(round(max([(nbright - nbwrong)/nbsol*100,0])))\n\ndef correct_items(nbright=0, nbwrong=0, nbsol=1, nbitems=1):\n    return int(round(max([(nbitems - 2*(nbsol - nbright + nbwrong))/nbitems*100,0])))\n\ndef exact_order(order):\n    n = len(order)\n    return 100 if order == list(range(n)) else 0\n\ndef kendall_tau(order):\n    n = len(order)\n    tau,_ = kendalltau(order, list(range(n)))\n    return int(round(max([0,tau])*100))\n\n\n\n",
    "customradio.py":"import random as rd\nfrom uuid import uuid4\nfrom components import Component\n\nclass CustomRadio(Component):\n\n    def __init__(self, **kwargs):\n        self.selector = 'c-radio-group'\n        self.decorator = 'CustomRadio'\n        self.selection = None\n        super().__init__(**kwargs)\n\n    def setitems(self, contents):\n        \"\"\"\n        Set items in the component.\n        \"\"\"\n        self.items = [{\"id\": str(uuid4()), \"content\": content} for content in contents]\n\n    def setsol_from_index(self, index):\n        \"\"\"\n        Set the component solution from an index.\n        \"\"\"\n        self._sol = self.items[index]['id']\n\n    def setsol_from_content(self, content):\n        \"\"\"\n        Set the component solution from a content.\n        \"\"\"\n        self._sol = next(item['id'] for item in self.items if item['content'] == content)\n\n    def shuffle(self):\n        \"\"\"\n        Shuffle the component items.\n        \"\"\"\n        rd.shuffle(self.items)\n\n    def sort(self):\n        \"\"\"\n        Sort the component items.\n        \"\"\"\n        self.items.sort(key = lambda item: item['content'])\n\n    def eval(self, display=True, disabled=True):\n        \"\"\"\n        Evaluate the answer stored in the component.\n        \"\"\"\n        score = 0\n        for item in self.items:\n            id = item['id']\n            if id == self._sol and id == self.selection:\n                score = 100\n                if display:\n                    item['css'] = 'success-state icon-check-after'\n            elif display and id != self._sol and id == self.selection:\n                    item['css'] = 'error-state icon-times-after'\n            elif display and id == self._sol and id != self.selection:\n                    item['css'] = 'icon-check-after'\n\n        self.disabled = disabled\n\n        return score\n",
    "customcheckbox.py":"import random as rd\nfrom uuid import uuid4\nfrom components import Component\nfrom scoring import *\n\nclass CustomCheckbox(Component):\n\n    def __init__(self, **kwargs):\n        self.selector = 'c-checkbox-group'\n        self.decorator = 'CustomCheckbox'\n        super().__init__(**kwargs)\n\n    def setitems(self, contents):\n        \"\"\"\n        Load items in the component.\n        \"\"\"\n        self.items = [{\"id\": str(uuid4()), \"content\": content} for content in contents]\n\n    def setsol_from_index(self, index):\n        \"\"\"\n        Set the component solutions from a list of indices.\n        \"\"\"\n        if isinstance(index,list):\n            self._sol = [self.items[i]['id'] for i in index]\n        elif isinstance(index,int):\n            self._sol = [self.items[index]['id']]\n\n    def setsol_from_content(self, content):\n        \"\"\"\n        Set the component solutions from a list of contents.\n        \"\"\"\n        if isinstance(index,list):\n            self._sol = [id for id in self.items if self.items['content'] in content]\n        elif isinstance(index,str):\n            self._sol = [next(item['id'] for item in self.items if item['content'] == content)]\n\n    def setdata_from_rw(self, right, wrong, nbitems=None, nbright=None):\n        \"\"\"\n        Set items and solutions from lists of right and wrong items.\n        \"\"\"\n        if nbitems is None:\n            nbitems = len(right) + len(wrong)\n        if nbright is None:\n            nbright = len(right)\n\n        self.setitems(rd.sample(right, nbright) + rd.sample(wrong, nbitems-nbright))\n\n        self.setsol_from_index(list(range(nbright)))\n\n        self.shuffle()\n\n    def shuffle(self):\n        \"\"\"\n        Shuffle the component items.\n        \"\"\"\n        rd.shuffle(self.items)\n\n    def sort(self):\n        \"\"\"\n        Sort the component items.\n        \"\"\"\n        self.items.sort(key = lambda item : item['content'])\n\n    def eval(self, display=True, disabled=True, scoring=\"RightMinusWrong\", custom_scoring=None):\n        \"\"\"\n        Evaluate the answer stored in the component.\n        \"\"\"\n        nbright, nbwrong = 0, 0\n\n        for item in self.items:\n            id = item['id']\n            if id in self._sol and item['checked']:\n                nbright += 1\n                if display:\n                    item['css'] = 'success-state icon-check-after'\n            elif id not in self._sol and item['checked']:\n                nbwrong += 1\n                if display:\n                    item['css'] = 'error-state icon-times-after'\n            elif id in self._sol and not item['checked'] and display:\n                item['css'] = 'icon-check-after'\n                          \n        if scoring == \"AllOrNothing\":\n            score = all_or_nothing(nbright, nbwrong)\n        elif scoring == \"RightMinusWrong\":\n            score = right_minus_wrong(nbright, nbwrong, nbsol=len(self._sol))          \n        elif scoring == \"CorrectItems\":\n            score = correct_items(nbright, nbwrong, nbsol=len(self._sol), nbitems=len(self.items))\n        elif scoring == \"Custom\":\n            score = custom_scoring(nbright, nbwrong, nbsol=len(self._sol), nbitems=len(self.items))\n        else:\n            raise ValueError(f\"'{scoring}' is not a valid scoring\")\n\n        self.disabled = disabled\n\n        return score\n\n\n\n",
    "customtextselect.py":"import uuid\nfrom components import Component\nimport random as rd\nimport re\nfrom scoring import *\n\nclass CustomTextSelect(Component):\n    def __init__(self, **kwargs):\n        self.selector = 'c-text'\n        self.decorator = 'CustomText'\n        self.text = \"\"\n        self._sol = []\n        super().__init__(**kwargs)\n\n    def settext(self, text):\n        \"\"\"\n        Set a text in the component after bracketting it.\n        \"\"\"\n        self.text = self.bracket(text)\n\n    def setdata_from_text(self,text):\n        self.text, self._sol = self.index_bracket(self.bracket(text))\n        \n    @staticmethod\n    def bracket(string):\n        \"\"\"\n        Bracket a text.\n\n        Parts between square brackets are stripped from these enclosing brackets.\n        Parts between curly brackets or double curly brackets are left unchanged.\n        In remaining parts, words are enclosed in curly brackets.\n        \"\"\"\n        # split the text\n        pattern = r\"\\{[^\\{\\}]*\\}|\\{\\{[^\\}]*\\}\\}|\\[[^\\]]*\\]|[^\\{\\}\\[\\]]+\"\n        lst = re.findall(pattern, string)\n\n        # process the different parts\n        for i in range(len(lst)):\n            s = lst[i]\n            if s[0] == \"[\":\n                lst[i] = s[1:-1]\n            elif s[0] == \"{\":\n                pass\n            else:\n                lst[i] = re.sub(r\"(\\w+)\", r\"{\\1}\", s)\n\n        return \"\".join(lst)\n    \n    @staticmethod\n    def index_bracket(string):\n        \"\"\"\n        Return the indices of the units between double curly brackets.\n        \"\"\"\n        pattern = r\"\\{[^\\{\\}]*\\}|\\{\\{[^\\}]*\\}\\}|[^\\{\\}]+\"\n        lst = re.findall(pattern, string)\n\n        selection = []\n        k = 0\n        for i in range(len(lst)):\n            s = lst[i]\n            if s[0] == \"{\":\n                if len(s) > 2 and s[1] == \"{\":\n                    selection.append(k)\n                    lst[i] = s[1:-1]\n                k += 1\n\n        return (\"\".join(lst), selection)\n\n    def eval(self, display=True, scoring=\"RightMinusWrong\", disabled=True, custom_scoring=None):\n        \"\"\"\n        Evaluate the answer stored in the component.\n        \"\"\"\n        indexselect = [unit['index'] for unit in self.selections]\n\n        right = list(set(indexselect).intersection(set(self._sol)))\n        wrong = list(set(indexselect).difference(set(self._sol)))\n        missed = list(set(self._sol).difference(set(indexselect)))\n\n        if display:\n            self.selections = [{'index': k, 'css': 'success-state'} for k in right]\n            self.selections += [{'index': k, 'css': 'error-state '} for k in wrong]\n            self.selections += [{'index': k, 'css': 'success-text-unit'} for k in missed]\n                          \n        if scoring == \"AllOrNothing\":\n            score = all_or_nothing(len(right), len(wrong))\n        elif scoring == \"RightMinusWrong\":\n            score = right_minus_wrong(len(right), len(wrong), nbsol=len(self._sol))          \n        #elif scoring == \"CorrectItems\":\n        #    score = correct_items(nbright, nbwrong, nbitems=len(self.items))\n        elif scoring == \"Custom\":\n            score = custom_scoring(nbright, nbwrong, nbsol=len(self._sol), nbitems=len(self.items))\n        else:\n            raise ValueError(f\"'{scoring}' is not a valid scoring\")\n\n        if disabled:\n            self.disabled = True\n\n        return score\n",
    "customdragdrop.py":"from components import Component\nfrom random import shuffle\nfrom uuid import uuid4\n\nclass MyComponent(Component):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def set_css(self, css_property, value): \n        css_string = css_property + ':' + value + ';\\n'   # the string to add in self.css\n        reg_ex = css_property + \":.+;\" # the regular expression to search for the property in self.css\n\n        if re.findall(reg_ex, self.css):  # if self.css contains the property, replace it with the new values\n            re.sub(reg_ex, css_string, self.css)\n        else: # otherwise just add the property to self.css\n            self.css+=css_string\n\n\n\n\ndef all_or_nothing(num_right=0, num_wrong = 0, total = 1):\n    if num_right == total:\n        return 100\n    else:\n        return 0\n\ndef right_minus_wrong(num_right=0, num_wrong = 0, total = 1):\n    if total == 0:\n        return 100\n    else:\n        return max([round((num_right-num_wrong)/total*100),0])\n\nclass CustomDragDrop(Component):\n\n    def __init__(self, **kwargs):\n        self.selector = 'c-drag-drop'\n        self.decorator = 'CustomDragDrop'\n        self.content = \"\"\n        self.group_id = \"\"\n        self.cloneable = False\n        super().__init__(**kwargs)\n\n    @classmethod\n    def Drop(cls, **kwargs):\n        return cls(id=str(uuid4()), droppable=True, cloneable = False, **kwargs)\n\n    @classmethod\n    def Label(cls, **kwargs):\n        return cls(id=str(uuid4()), droppable=False, **kwargs)\n\n\"\"\"   @classmethod\n   def Drops(cls, arg, **kwargs):\n        if isinstance(arg,int):\n            return [cls.Drop(**kwargs) for i in range(arg)]\n        if isinstance(arg,list):\n            return [cls.Drop(content=content,**kwargs) for content in arg]\n\n    @classmethod\n    def Labels(cls, arg, **kwargs):\n        if isinstance(arg,int):\n            return [cls.Label(**kwargs) for i in range(arg)]\n        if isinstance(arg,list):\n            return [cls.Label(content=content,**kwargs) for content in arg]\n\n    @staticmethod\n    def eval(drop, sol, display=True, grading=\"CorrectItems\", disabled=True):\n        feedback=\"\"\n        score=100\n        for i in range(len(drop)):\n            if drop[i].content==sol[i]:\n                drop[i].css = \"success-state\"\n            else:\n                score=0\n                drop[i].css = \"error-state\"\n            drop[i].disabled = True\n        return (score,feedback)\n\"\"\"\n\nclass DragDropGroup():\n\n    def __init__(self, **kwargs):\n    \n        self.serialize = \"DragDropGroup\"\n        self.id = str(uuid4())    # generates a random id for the group\n        self.labels = {}            # labels/drops are dictionaries whose values are objects of class Label/Drop, the key is referred to below as the label/drop name.\n        self.drops = {}\n        self.cloneable = True    # Tells if a label can be used several times or not\n        self.css = \"\"\n        self._matches = []       # List of correct matches between a label and a drop. A match is a pair of cid's\n                                          # underscore to make matches  invisible in the html.\n        if 'id' in kwargs: # comes first because id is copied in labels and drops\n            self.id = kwargs['id']\n        if 'cloneable' in kwargs: # comes first because cloneable is translated in labels and drops\n            self.cloneable = kwargs['cloneable']\n        if 'css' in kwargs:\n            self.css = kwargs['css']\n        if 'labels' in kwargs:\n            self.set_label(kwargs['labels'])\n        if 'drops' in kwargs:\n            self.set_drop(kwargs['drops'])\n        if 'matches' in kwargs:# format of a match: (cid of label, cid of drop_). self.matches is the list of allowable matches between a label and a drop.\n            self.set_match(kwargs['valid_matches'])\n    \n    @classmethod\n    def fromdict(cls, **d):\n        obj = cls()\n        for k, v in d.items():\n            setattr(obj, k, v)\n        return obj\n\n    def set_label(self, labels):\n         self.labels = {}\n         self.add_label(labels)\n\n    def add_label(self, labels): \n        \"\"\" \n        add_label can have as argument:\n         1) a string, which is then both the name (= key of the label in self.labels) and visible content of the label,\n         2) a dictionary, which is then used to update self.labels, adding to each component the group_id and cloneable info\n         3) a list of strings, and then a label is added for each string as in 1). \n         \"\"\"\n        if isinstance(labels, str):\n            self.labels[labels] = CustomDragDrop.Label(content = labels, css=self.css, group_id = self.id, cloneable = self.cloneable)\n        if isinstance(labels, dict):\n            self.labels.update({label_name:  CustomDragDrop.Label(content = label_content, css=self.css, group_id = self.id, cloneable = self.cloneable) for (label_name, label_content) in labels.items()})\n        if isinstance(labels, list):\n            self.labels.update({string:  CustomDragDrop.Label(content = string, css=self.css, group_id = self.id, cloneable = self.cloneable) for string in labels})\n\n    def set_drop(self, drops):\n         self.drops = {}\n         self.add_drop(drops)\n\n    def add_drop(self, drops): # similar to add_label, only drops do not have the cloneable info.\n        if isinstance(drops, str):\n            self.drops[drops] = CustomDragDrop.Drop(content = drops, css=self.css, group_id = self.id)\n        if isinstance(drops, dict):\n            self.drops.update({drop_name:  CustomDragDrop.Drop(content = drop_content, css=self.css, group_id = self.id) for (drop_name, drop_content) in drops.items()})\n        if isinstance(drops, list):\n            self.drops.update({string:  CustomDragDrop.Drop(content = string, css=self.css, group_id = self.id) for string in drops})\n\n    def set_match(self, matches): # self._matches is a list of pairs (label_cid, drop_cid)\n        self._matches = matches\n\n    def set_match_by_name(self, drop, matches):\n        self._matches = []\n        self.add_match_by_name(drop, matches)\n\n    def add_match_by_name(self, drop, matches): # adds one or multiple matches to self._matches, the drop and label(s) are specified by their name.\n       if isinstance(matches, list):\n            self._matches += [(self.labels[label_name].cid, self.drops[drop].cid) for label_name in matches]\n       else: #matches is not a list. it must be a key to the dict self.labels\n            self._matches.append((self.labels[matches].cid,self.drops[drop].cid))\n\n    def set_match_by_content(self, matches):\n        self._matches = []\n        self.add_match_by_content(matches)\n\n    def get_label_by_content(self, content):\n        for key, value in self.labels.items():\n            if value.content == content:\n                return value\n                \n    def add_match_by_content(self, drop, matches): # adds one or multiple matches to self.matches, the drop is specified by name, \n                                                                            #and label(s) are specified by their content\n       if isinstance(matches, str):\n            label = self.get_label_by_content(matches)\n            self._matches.append((label.cid, self.drops[drop].cid))\n       if isinstance(matches, list):\n            self._matches += [(self.get_label_by_content(label_content).cid, self.drops[drop].cid) for label_content in matches]\n    \n    def shuffle_labels(self):\n        a = list(self.labels.items())\n        shuffle(a)\n        self.labels = dict(a)\n    \n    def eval(self, display=True, grading_function= all_or_nothing, disabled=True):\n        \"\"\" An answer is a pair (label drop). The evaluation uses 3 integers: total is the maximum number of correct answers which can be given \n        (depends on wether cloneable is True or False), num_right is the number of correct answers given (= pairs belonging to self.matches), num_wrong is the \n        number of wrong answers given (= pairs not belonging to self.matches). a user specified function is used to compute the grade from these 3 integers.\n        \"\"\"\n        feedback=\"\"\n        score=100\n\n        num_right, num_wrong = 0, 0\n\n        for drop_name, drop in self.drops.items():\n            drop.disabled = True\n            drop_data = [drop.droppedId, drop.cid] \n            # BUG? si on met (drop.droppedId, drop.cid), \u00e7a marche pas, comme si les tuples avaient \n            # \u00e9t\u00e9 transform\u00e9s en listes dans le grader\n            # DEBUG feedback+='dropdata:'+str(drop_data)+'<br>'\n            if drop.droppedId == '':\n                pass\n            elif drop_data in self._matches:\n                num_right += 1\n                drop.css += \"success-state\"\n            else:\n                num_wrong +=1\n                drop.css += \"error-state\"           \n   \n        possible_labels = {label for (label, drop) in self._matches} # set comprehension, no duplicates\n        possible_drops = {drop for (label, drop) in self._matches} # set comprehension, no duplicates\n        if self.cloneable == True:\n            total = len(possible_drops)\n        else:\n            total = min(len(possible_drops), len(possible_labels)) # en fait c'est plus compliqu\u00e9 que \u00e7a: \n        # il faut calculer le max de drops atteints par une application injective\n        # qui associe \u00e0 un label un drop autoris\u00e9. C'est un maximum match d'un graphe bipartite, \n        # et \u00e7a peut se calculer par programmation lineaire, cf Matousek-Gartner\n                  \n        score = grading_function(num_right, num_wrong, total)\n        # DEBUG feedback += str(self._matches)+'<br>'\n        # DEBUG feedback+=str([drop.cid for drop_name, drop in self.drops.items()])+'<br>'\n        # DEBUG feedback+= str([drop.cid for drop_name, drop in self.labels.items()])\n        feedback = ''\n        return (score,feedback)\n\n    \n        \n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },

  "__extends":[
    {
      "path":"model/mathjsxgraph.pl",
      "line":"extends = /model/mathjsxgraph.pl\n",
      "lineno":5,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/math.pl",
      "line":"extends = /model/math.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/basic.pl",
      "line":"extends = basic.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/temp.pl",
      "line":"extends = temp.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/temp.pl",
      "line":"extends = temp.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/basic.pl",
      "line":"extends = basic.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/temp.pl",
      "line":"extends = temp.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/temp.pl",
      "line":"extends = temp.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    },
    {
      "path":"model/temp.pl",
      "line":"extends = temp.pl\n",
      "lineno":1,
      "directory_name":"Yggdrasil"
    }
  ],
  "title":"Affixe d'un nombre complexe",
  "before":"a = randint(-5, 5, [0])\nb = randint(-5, 5, [0])\nz = a + b*I\njxg.setscript(script_init)",
  "jxg":{
    "attributes":{
      "showNavigation":false,
      "boundingbox":[
        -6,
        6,
        6,
        -6
      ]
    },
    "cid":"add5796d-4c85-479e-ab20-4ed92ad2b562",
    "selector":"c-math-drawer",
    "decorator":"CustomJSXGraph"
  },
  "script_init":"board.create('grid',[],{gridX:1,gridY:1});\nboard.create('axis',[[0,0],[1,0]],{name:'Re',withLabel:true,label:{position:'urt',offset:[-5,10]},ticks:{visible: false}});\nboard.create('axis',[[0,0],[0,1]],{name:'Im',withLabel:true,label:{position:'urt',offset:[10,0]},ticks:{visible: false}});\nconst M = board.create('point',[0, 0],{size:2,name:'M',color:'red'});\n\nfunction getMouseCoords(e) {\n    let cPos = board.getCoordsTopLeftCorner(e);\n    let absPos = JXG.getPosition(e);\n    let dx = absPos[0]-cPos[0];\n    let dy = absPos[1]-cPos[1];\n    return new JXG.Coords(JXG.COORDS_BY_SCREEN, [dx, dy], board);\n}\n\nfunction down(e) {\n    let coords = getMouseCoords(e);\n    M.setPosition(JXG.COORDS_BY_USER,[coords.usrCoords[1], coords.usrCoords[2]]);\n}\n\nboard.on('down', down)",
  "text":"Placer le point $% M %$ d'affixe $%{{ z|latex }}%$ dans le plan ci-dessous.",
  "script_solution":"\nboard.create('point',[1, 2],{size:2,name:'Sol',color:'green'});\n// board.create('point',[{{x}}, {{y}}],{size:2,name:'',color:'red'});",
  "evaluator":"x, y = jxg.getpoint('M')\nfrom math import hypot\nif hypot(x-a, y-b) < 0.1:\n    score = 100\n    jxg.addscript(script_solution, globals())\nelse:\n    score = 0\n    jxg.addscript(script_solution, globals())\nfeedback=\"\"",
  "old":"x= drawer.points['M']['x']\ny= drawer.points['M']['y']\n\nfrom jinja2 import Template\nfrom math import hypot\nif hypot(x-a, y-b)<0.1:\n     score=100\n     drawer.script = Template(script_solution).render(locals())\n     drawer.points = {}\n     drawer.disabled = True\nelse:\n     score=0\n     if nbattempt + 1 >= int(maxattempt):\n        drawer.script = Template(script_solution).render(locals())\n        drawer.points = {}\n        drawer.disabled = True\nfeedback=\"\"",
  "form":"{{ jxg|component }}",
  "settings":{
    "feedback":"rightwrong",
    "maxattempt":1
  },
  "feedback":{
    "Success":"\n",
    "NotEqual":"\n",
    "NotExpr":"La r\u00e9ponse doit \u00eatre une expression math\u00e9matique.",
    "NotRealOrInf":"La r\u00e9ponse doit \u00eatre un nombre r\u00e9el ou $! +\\infty !$ ou $! -\\infty !$.",
    "NotRSet":"La r\u00e9ponse doit \u00eatre un intervalle ou une r\u00e9union d'intervalles.",
    "NotCplx":"La r\u00e9ponse doit \u00eatre un nombre complexe.",
    "NotCplxCartesian":"La r\u00e9ponse doit \u00eatre un nombre complexe sous forme cart\u00e9sienne.",
    "NotCplxExponential":"La r\u00e9ponse doit \u00eatre un nombre complexe sous forme exponentielle.",
    "NotSet":"La r\u00e9ponse doit \u00eatre un ensemble.",
    "NotTuple":"La r\u00e9ponse doit \u00eatre un n-uplet (un vecteur ligne).",
    "NotPoly":"La r\u00e9ponse doit \u00eatre un polyn\u00f4me.",
    "NotPhysical":"La r\u00e9ponse doit \u00eatre une valeur num\u00e9rique suivie d'une unit\u00e9 physique.",
    "PhysicalNotNumeric":"La partie num\u00e9rique doit \u00eatre un nombre d\u00e9cimal.",
    "WrongUnit":"Mauvaise unit\u00e9.",
    "RSetNotDisjoint":"Les ensembles de cette r\u00e9union ne sont pas disjoints. La r\u00e9ponse peut \u00eatre simplifi\u00e9e.",
    "PolyNotExpanded":"La r\u00e9ponse doit \u00eatre un polyn\u00f4me d\u00e9velopp\u00e9.",
    "PolyNotFactorized":"La r\u00e9ponse doit \u00eatre un polyn\u00f4me factoris\u00e9.",
    "MatWrongSize":"La matrice n'a pas la bonne taille.",
    "NotRatSimp":"L'expression peut encore \u00eatre simplifi\u00e9e.",
    "Duplicates":"Il y a des doublons dans l'ensemble.",
    "UnauthorizedFunc":"Votre r\u00e9ponse utilise des fonctions non-autoris\u00e9es."
  },
  "style":{
    "basic":".icon-check-after p::after {\n    font-family: \"Font Awesome 5 Free\";\n    color: #155724;\n    margin-left: 1em;\n    content: \"\\f00c\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-times-after p::after {\n    font-family: \"Font Awesome 5 Free\";\n    color: #721c24;\n    margin-left: 1em;\n    content: \"\\f00d\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-check-before p::before {\n    font-family: \"Font Awesome 5 Free\";\n    color: #155724;\n    margin-right: 1em;\n    content: \"\\f00c\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-times-before p::before {\n    font-family: \"Font Awesome 5 Free\";\n    color: #721c24;\n    margin-right: 1em;\n    content: \"\\f00d\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.error-text-unit {\n    color: #721c24;\n    text-decoration: line-through red;\n}\n\n.success-text-unit {\n    color: #155724;\n    text-decoration: underline wavy green;\n}"
  },
  "extracss":"<style>\n.icon-check-after p::after {\n    font-family: \"Font Awesome 5 Free\";\n    color: #155724;\n    margin-left: 1em;\n    content: \"\\f00c\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-times-after p::after {\n    font-family: \"Font Awesome 5 Free\";\n    color: #721c24;\n    margin-left: 1em;\n    content: \"\\f00d\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-check-before p::before {\n    font-family: \"Font Awesome 5 Free\";\n    color: #155724;\n    margin-right: 1em;\n    content: \"\\f00c\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.icon-times-before p::before {\n    font-family: \"Font Awesome 5 Free\";\n    color: #721c24;\n    margin-right: 1em;\n    content: \"\\f00d\";\n    vertical-align: middle;\n    font-weight: 900;\n}\n\n.error-text-unit {\n    color: #721c24;\n    text-decoration: line-through red;\n}\n\n.success-text-unit {\n    color: #155724;\n    text-decoration: underline green;\n}\n</style>",
  "extrajs":"<script>\n    function onReadyPL(nodes) {\n        const actions = nodes.actions;\n        actions.find('.action-save').hide();\n        actions.find('.action-reset').hide();\n        actions.find('.action-next').hide();\n\n        const { origin, pathname }\u00a0 = document.location;\n        const link = origin + pathname;\n\n        const buttons = actions.find('.btn-group');\n\n        {% if \"reroll\" in internals.buttons %}\n        buttons.append(`\n            <a type=\"button\" class=\"btn btn-warning action-reroll\" href=\"`+link+`?action=reroll\">\n                <i class=\"fas fa-dice\"></i> Nouveau tirage\n            </a>\n        `);\n        {% endif %}\n\n        {% if not \"submit\" in internals.buttons %}\n        actions.find('.action-submit').hide();\n        {% endif %}\n    }\n</script>"
}
